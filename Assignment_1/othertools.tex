\section{Additional measures}
Configuring \textbf{Arpwatch} as described in the previous section is obviously not enough to guarantee a certain level of security in the target network, so we decided to take some extra measures that were not required by the assignment.\\
As a best practice, we chose to change the default passwords of every account in the machines of the network, and also the password for the admin account for the Internal Router has been changed. Strong, secure passwords on the \textbf{arpwatch machine} are a must-have in order for the monitoring system to actually be effective.\\
Apart from best practices, we needed to take into account possible threats such as \textbf{escalation of privilege} and \textbf{tampering} with the scripts' input in the \textbf{arpwatch machine}, so to make it difficult for an adversary to disrupt the monitoring system.

\subsection{Escalation of privilege on the Arpwatch machine}
This issue is pretty self-explanatory: in order for the script to be running, \textbf{root} has to be logged-in in the machine, meaning that an adversary could simply access it knowing its location (i.e., its IP address) and, being already logged-in as \textbf{root}, simply terminate the execution of the monitoring scripts, e.g. just by logging out of the account. Notice that this scenario could lead to even worse results for our system, such as the adversary being able to do basically everything he wants from the \textbf{arpwatch machine}. First measure we took was to actually launch the script at login such as, even when \textbf{root} or any other user logs out from bash, the monitoring script keeps running: this result was obtained through the \textbf{nohup} command being concatenated to the script when it is launched. This way, even if the user who executed the script logs out, it keeps running.\\
We do not need the \textbf{root} account to be logged in now to keep watching for possible spoofing attacks, but it is in general a best practice to execute scripts with the least possible privilege, so monitoring through \textbf{root} still seems a pretty bad idea. Indeed, if an adversary is granted access as \textbf{root}, he can still terminate the execution of the script, reboot or shut down the system. As a further security measure, a new account was created on the machine - \textbf{watchdog} - with no directory assigned and no privileges granted, so that it cannot create new files, edit old ones or execute files he does not own. This user basically doesn't own any file, but is given some specific permissions in order to perform the monitoring activity: first, he is able to \textit{only read} the arpwatch logs under \textit{/var/log/arpwatch.log}. Thanks to the \textbf{sudo} tool (by modifying \textit{visudo}), \textbf{watchdog} is able to launch from login the monitoring scripts - so that he can read and execute them, but not modify or delete them - and the \textbf{Python script} (so basically everything already existing under \textit{home} directory), which has been granted the privilege to actually create sockets and send packets through the \textbf{setcap} tool.\\
Also, the file \textbf{arp.dat} where the tool stores the arp entries is usually located at \textit{/var/lib/arpwatch}, but when run from \textbf{watchdog} arpwatch actually runs from directory \textbf{/}, so a new file \textbf{arp.dat} was created and owned by \textbf{root} in this directory. We tested and found out that \textbf{arpwatch}, when run by \textbf{watchdog}, uses this file and reads from it: this approach should be more secure since \textbf{watchdog} user cannot write to this second \textbf{arp.dat}, but \textbf{arpwatch} can still edit it while running without saving it, so it is able to store all the arp entries it needs there. When the script is eventually terminated by performing a rebot or a shut down from \textbf{root}, the file isn't saved, meaning the arp entries are lost and new stations will have to be re-discovered at new script startup, but this doesn't seem to affect badly the live detection, supposing a reboot of the machine will not occur frequently. Notice that every other action in the machine requires \textbf{watchdog} to input its own password, which was changed, and he cannot create new files without \textit{sudo} since he does not even own a directory - so, even if files executed in \textbf{Python} environment are actually able to send packets over the network, \textbf{watchdog} cannot create nor execute them: if he wants to, he needs to input its own password to be granted superuser privileges.\\
Furthermore, commands such as \textbf{reboot} and \textbf{shutdown} are disabled by default for \textbf{watchdog} without \textit{sudo} command, and even if the adversary logs out from this account, the monitoring script will keep running as previously mentioned.\\
Please notice also that \textit{sudo} is always requested to perform such actions - as, basically, every other action - since the \textit{sudoers} file was modified so that the default value for the \textit{timestamp$_$timeout} was set to \textbf{0}. At this point, the adversary cannot pose a threat to the machine that is worse than just killing the process related to the monitoring script, which at least can be prevented by logging in as \textbf{watchdog}, let the machine run the script and then log out - if passwords of the two accounts are not known to the adversary, the script's execution cannot be terminated.\\
As a final, further security measure, the \textbf{root} account was locked - so it is not possible to login as \textbf{root} - with the \textit{sudo passwd -l root} command.\\
Since the adversary is able to execute the monitoring scripts, he could provide \textbf{scapySendPacket.py} a bad input and exploit it to send packets over the network, which is an issue we deal with in the next subsection.\\

\subsection{Input validation in scapySendPacket.py}
The first, non-security related input validation phase requires the input to be at least two strings long. This is due to the fact that at least one string is required to match the target MAC address of the packet (the very first input string) and another one to be the payload, which we do not want to be empty. An error string will alert the user tampering with the input in this case, and the script will exit.\\
Another input validation mechanism was introduced in the Python script to actually prevent an adversary which gained access to a shell in the machine to abrirtarily send packets over the LAN exploiting this script itself.\\
Since we want \textit{scapySendPacket.py} to be triggered by new log lines in the arpwatch log file, before actually sending the requested payload to the specified MAC address, the script reads the log file and verifies that the payload itself is actually contained in this file.\\
This means that an adversary will not be able to send packets exploiting this script with an arbitrary payload, since the payload \textbf{must} be contained in the log file, else the script will terminate before sending the packet. Obviously, an adversary could still send its own packets by just setting as their input log lines that are already present in the log file, but at least it would be obvious to the sysadmin, and maybe also to the users receiving those packets, that such an attack is being performed: all the log lines - and thus, the payloads of the packet - contain \textit{date} and \textit{time}, so if they do not correspond to the date and time the packet was actually received, an user should still be able to tell that something's off.
