\section{Policy Implementation}
While evaluating the policy in the previous paragraph, we have already proposed a high-level description of the rules to be implemented at each interface of the two firewalls. Notice that, for instance, the rules we applied at the \textbf{Internal interface} of the \textbf{Main Router}, could have also been applied, instead, at the \textbf{External interface} of the \textbf{Internal Router} or, to have a complete in-depth defence, the same rules could have been applied at both interfaces - which could also be the best solution in order to prevent bad scenarios like the failure of one of the two firewalls.\\
Also, there is another interesting fact about OPNSense Firewall configuration: it tracks connections by default, so that every packet in a TCP connection which has already been \textit{established} and has been accepted, is automatically accepted (\textit{pass} action) by default. This means that if we set a rule to allow machine A to ping machine B through ICMP protocol and then another one which rejects by default any other connection on that interface, since OPNSense by default applies to the packet the very first rule that matches, machine B's response will be automatically accepted too by the firewall, while if machine B initiates a new connection by pinging machine A, the firewall will not allow it - and we can verify this on the testing paragraph.\\
While implementing this policy, several \textbf{aliases} had to be defined in OPNSense's Firewall service at each of the two routers. These aliases could either be single hosts or single subnetworks, which were in some cases already present by default. This way, machines or subnets that were allowed to send or receive specific packets on an interface were addressed more precisely, and we were able to make important distinctions between hosts in the same subnet but with different policies - i.e., \textbf{Web Service} and \textbf{Proxy Service} in the \textbf{DMZ subnet}, or the two internal services \textbf{DNS} and \textbf{Log}.\\
These are the rules that were specified on each of the two routers:\\
\textbf{Internal Router:}
\begin{itemize}
\item \textbf{Clients Interface}: only accept incoming packets on this interface with destination ports 80(HTTP), 443(HTTPS), 22(SSH), 53(UDP-DNS) and 3128(Proxy Service). Anything else will be discarder, since clients are not supposed to perform different actions and exploit different protocols than the aforementioned ones. For practical reasons, also packets on port 8443 (for \textbf{zentyal} panel service) are allowed - but this might be changed;
\item \textbf{Servers Interface}: only accept incoming packets on this interface with destination port 53(UDP-DNS) or 514(UDP-SYSLOG, only if coming from \textbf{DMZ subnet}) and on port 22(SSH) only if coming from the \textbf{Clients subnet}, otherwise discard. This means that the two servers can only be reached by Clients or DMZ subnetworks, and only for the services that they provide (SYSLOG, DNS, SSH);
\item \textbf{External Interface:} we can either set the same rules of the \textbf{Main Router}'s \textbf{Internal Interface} to have a more robust setup, or leave this with its default configuration;
\end{itemize}
\textbf{Main Router:}
\begin{itemize}
\item \textbf{Internal Interface:} only accept incoming packets on this interface on ports 80(HTTP) and 443(HTTPS) between \textbf{Clients subnet} and \textbf{External services subnet}, or ports 22(SSH) and 3182(Proxy) between \textbf{Clients subnet} and \textbf{DMZ subnet}, or ports 53(UDP-DNS) and 514(UDP-SYSLOG) between \textbf{DMZ subnet} and \textbf{Internal services subnet}, otherwise discard. This means the Client host will only be able to reach the external web services, or the proxy to actually reach the WAN, and won't be able to do it directly by itself. Furthermore, SSH is eanbled for Client hosts to reach the \textbf{DMZ subnet} and the services offered by the \textbf{Internal servers} are reachable from the machines in the DMZ;
\item \textbf{DMZ Interface:} we want the proxy server to be able to reach the internet via HTTP$/$HTTPS protocol, so we specify that this interface has to accept incoming packets specifically from the \textbf{Proxy server} and with \textbf{any} destination address on ports HTTP$/$HTTPS, and the same goes (but reversed) for the \textbf{web server} which we want to be accessible on ports HTTP$/$HTTPS from the Internet. However, the \textbf{proxy service} itself must be only available for client hosts in the \textbf{Clients subnet}, so we should also specify that this interface should accept incoming packets on port 3182 of the Proxy machine with source address in the \textbf{Clients subnet}. The aforementioned rules for DNS/SYSLOG services in the Internal Services apply also here on this interface, while every other packet which is not \textit{white-listed} must be rejected;
\item \textbf{WAN Interface:} this interface should be the first line of prevention against intruders from the Internet, so it only has to accept - as specified by the policy - connections with destination port 80 or 443 on the \textbf{web server} machine in DMZ and connections to any other machine in the Internet on port 80 or 443 if they are initiated by the \textbf{Proxy} machine in DMZ: every other packet incoming on this interface should be rejected;
\item \textbf{External services Interface:} since anything that is not specifically allowed must be denied, this interface should only allow external clients to establish a connection with their DNS service and an HTTP$/$HTTPS connection with the internal clients of our network, while anything else (including HTTP$/$HTTPS with \textbf{WAN} or SSH with internal clients) should be not allowed.
\end{itemize}

\textit{Please notice that for practical reasons, hosts in the Clients subnetwork have also been granted the possibility to access the two routers via their HTTP service.} This is not specified by the policy and thus should not be allowed, but since we are still implementing the whole infrastructure, we need access to this service from this subnetwork. At the end of the whole process, this rule should be disabled.
